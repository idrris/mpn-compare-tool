# EOL/eol_attr_extractor.py
from __future__ import annotations
import os, re, time, unicodedata, requests
from typing import Any, Dict, Optional, List
from urllib.parse import quote_plus

# Reuse your existing Digi-Key helpers if needed later (kept for compatibility)
from API.digikey import get_by_mpn_exact, get_by_mpn  # do not edit this file

# NEW: ranker (model/temp hardcoded inside rank_params.py; only OPENAI_API_KEY needed)
try:
    from EOL.rank_params import rank_parameter_ids
except Exception:
    rank_parameter_ids = None  # type: ignore

# ---------------- Digi-Key endpoints ----------------
DIGIKEY_TOKEN_URL = "https://api.digikey.com/v1/oauth2/token"
DK_KEYWORD_URL    = "https://api.digikey.com/products/v4/search/keyword"
DK_DETAILS_TPL    = "https://api.digikey.com/products/v4/search/{productNumber}/productdetails"

# ---------------- Mouser endpoints (self-contained) ------------------
MOUSER_KEYWORD_URL = "https://api.mouser.com/api/v1/search/keyword"  # ?apiKey=...

DEBUG = os.getenv("DK_ATTR_DEBUG", "0").strip().lower() in ("1", "true", "yes", "on")

# ---------------- utilities ----------------
def _env_clean(key: str) -> Optional[str]:
    v = os.getenv(key)
    if v is None:
        return None
    v = v.strip()
    if (v.startswith('"') and v.endswith('"')) or (v.startswith("'") and v.endswith("'")):
        v = v[1:-1].strip()
    return v or None

def _headers(token: str) -> Dict[str, str]:
    return {
        "Authorization": f"Bearer {token}",
        "X-DIGIKEY-Client-Id": os.getenv("DIGIKEY_CLIENT_ID", ""),
        "X-DIGIKEY-Locale-Site": os.getenv("DIGIKEY_SITE", "US"),
        "X-DIGIKEY-Locale-Language": os.getenv("DIGIKEY_LANG", "en"),
        "X-DIGIKEY-Locale-Currency": os.getenv("DIGIKEY_CURR", "USD"),
        "Accept": "application/json",
        "Content-Type": "application/json",
    }

def _mouser_headers() -> Dict[str, str]:
    return {
        "Accept": "application/json",
        "Content-Type": "application/json",
    }

def _request(method: str, url: str, *, headers: Dict[str, str], json_body: Any = None,
             retries: int = 2, backoff: float = 0.6):
    attempt = 0
    while True:
        try:
            if method.upper() == "GET":
                r = requests.get(url, headers=headers, timeout=25)
            else:
                r = requests.post(url, headers=headers, json=json_body, timeout=25)
            if r.status_code in (429, 500, 502, 503, 504) and attempt < retries:
                attempt += 1
                time.sleep(backoff * attempt)
                continue
            r.raise_for_status()
            return r
        except Exception as e:
            if DEBUG:
                print(f"[DK_ATTR] {method} {url} err:", e)
            return None

# ---------------- Digi-Key token ----------------
def _get_digikey_token() -> Optional[str]:
    """
    1) Use DIGIKEY_ACCESS_TOKEN if provided (handy for reuse).
    2) Else get a client-credentials token with DIGIKEY_CLIENT_ID/SECRET.
    """
    direct = _env_clean("DIGIKEY_ACCESS_TOKEN")
    if direct:
        if DEBUG: print("[DK_ATTR] using DIGIKEY_ACCESS_TOKEN from env")
        return direct

    client_id = _env_clean("DIGIKEY_CLIENT_ID")
    client_secret = _env_clean("DIGIKEY_CLIENT_SECRET")
    if not client_id or not client_secret:
        if DEBUG: print("[DK_ATTR] missing DIGIKEY_CLIENT_ID/SECRET")
        return None
    try:
        r = requests.post(
            DIGIKEY_TOKEN_URL,
            data={"grant_type": "client_credentials", "client_id": client_id, "client_secret": client_secret},
            timeout=25,
        )
        if not r.ok:
            if DEBUG: print("[DK_ATTR] token http", r.status_code, r.text[:200])
            return None
        tok = (r.json() or {}).get("access_token")
        if DEBUG: print("[DK_ATTR] obtained client_credentials token" if tok else "[DK_ATTR] token missing in response")
        return tok
    except Exception as e:
        if DEBUG: print("[DK_ATTR] token err", e)
        return None

# ---------------- parameter normalization ----------------
def _to_attributes_map(parameters: Any) -> Dict[str, Any]:
    """
    Normalize Digi-Key parameter rows into {name: value}.
    Handles ProductDetails/Keyword schemas (ParameterText/ValueText) and a few fallbacks.
    """
    out: Dict[str, Any] = {}
    if not parameters or not isinstance(parameters, (list, tuple)):
        return out

    def pick_name(d: Dict[str, Any]) -> str:
        for k in ("ParameterText", "Parameter", "Name", "DisplayName"):
            v = d.get(k)
            if isinstance(v, str) and v.strip():
                return v.strip()
        return "Attribute"

    def pick_value(d: Dict[str, Any]) -> str:
        for k in ("ValueText", "Value"):
            v = d.get(k)
            if isinstance(v, str) and v.strip():
                return v.strip()
        vals = d.get("Values")
        if isinstance(vals, list):
            joined = ", ".join([str(x).strip() for x in vals if str(x).strip()])
            if joined:
                return joined
        for k in ("DisplayValue", "Text", "Unit"):
            v = d.get(k)
            if isinstance(v, str) and v.strip():
                return v.strip()
        return ""

    for row in parameters:
        if not isinstance(row, dict):
            continue
        name = pick_name(row)
        val  = pick_value(row)
        if not val:
            continue
        if name in out and out[name] != val:
            out[name] = f"{out[name]}, {val}"
        else:
            out[name] = val
    return out

def _mouser_attrs_to_map(rows: Any) -> Dict[str, Any]:
    """Normalize Mouser ProductAttributes → {name: value} (walks full array)."""
    out: Dict[str, Any] = {}
    if not isinstance(rows, list):
        return out
    for r in rows:
        if not isinstance(r, dict):
            continue
        name = str(r.get("AttributeName") or "").strip()
        val  = str(r.get("AttributeValue") or "").strip()
        if not name or not val:
            continue
        if name in out and out[name] != val:
            out[name] = f"{out[name]}, {val}"
        else:
            out[name] = val
    return out

# --------- MPN normalization used only for COMPARISON (not for query) ----------
def _norm_mpn(s: Any) -> str:
    """Uppercase and strip all non A–Z/0–9 (handles '-', '/', en/em-dash, spaces, etc.)."""
    return re.sub(r"[^A-Z0-9]", "", str(s or "").upper())

# --------- MPN variants used for SEARCH (we try slash & dash explicitly) -------
_DASHES = r"[\u2010\u2011\u2012\u2013\u2014\u2015\u2212\-]"  # ascii dash + unicode dashes
def _mpn_variants_for_search(mpn: str) -> List[str]:
    """
    Generate deliberate query variants WITHOUT permanently changing the user's string:
      1) original as-is
      2) replace '-' dashes with '/' (helps cases like '4414F-2' vs '4414F/2')
      3) replace '/' with '-' (some sites index dashed)
      4) remove all dashes/slashes (pure alnum)
      5) replace dashes with spaces (some keyword engines like this)
    """
    out: List[str] = []
    s = (mpn or "").strip()
    if not s:
        return out
    s = unicodedata.normalize("NFC", s)
    out.append(s)

    # 2) '-' → '/'
    m2 = re.sub(_DASHES, "/", s)
    if m2 not in out:
        out.append(m2)

    # 3) '/' → '-'
    m3 = s.replace("/", "-")
    if m3 not in out:
        out.append(m3)

    # 4) remove dash & slash
    m4 = re.sub(_DASHES, "", s).replace("/", "")
    if m4 and m4 not in out:
        out.append(m4)

    # 5) dashes → space
    m5 = re.sub(_DASHES, " ", s)
    m5 = re.sub(r"\s{2,}", " ", m5).strip()
    if m5 and m5 not in out:
        out.append(m5)

    return out

# ---------------- keyword search helpers (Digi-Key) ----------------
def _keyword_exact_hit(token: str, mpn_query: str) -> Optional[Dict[str, Any]]:
    """
    POST /products/v4/search/keyword with Keywords=mpn_query.
    Prefer exact ManufacturerPartNumber match; else return the first product.
    """
    payload = {"Keywords": mpn_query, "RecordCount": 12}
    r = _request("POST", DK_KEYWORD_URL, headers=_headers(token), json_body=payload)
    if not r:
        return None

    try:
        data = r.json() or {}
    except Exception:
        return None

    products = data.get("Products") or data.get("products") or []
    if not isinstance(products, list) or not products:
        return None

    target = _norm_mpn(mpn_query)  # dash/space/slash tolerant comparison
    def _mpn_of(p: Dict[str, Any]) -> str:
        return _norm_mpn(p.get("ManufacturerPartNumber") or p.get("manufacturerPartNumber") or "")

    exact = [p for p in products if _mpn_of(p) == target]
    hit = exact[0] if exact else products[0]
    if DEBUG:
        print("[DK_ATTR] keyword selected → ProductNumber:",
              hit.get("ProductNumber") or hit.get("productNumber"),
              "MPN:", hit.get("ManufacturerPartNumber"))
    return hit

def _details_for_product_number(token: str, product_number: str) -> Optional[Dict[str, Any]]:
    url = DK_DETAILS_TPL.format(productNumber=quote_plus(product_number))
    r = _request("GET", url, headers=_headers(token))
    if not r:
        return None
    try:
        return r.json() or {}
    except Exception:
        return None

# ---------------- Mouser helpers (self-contained) ----------------
def _mouser_keyword_hit(mpn_query: str) -> Optional[Dict[str, Any]]:
    """
    POST /api/v1/search/keyword?apiKey=... with:
      {"SearchByKeywordRequest":{"keyword": mpn_query, "records": 25, "startingRecord": 0}}
    Select exact ManufacturerPartNumber match when possible, else first item.
    """
    api_key = _env_clean("MOUSER_API_KEY")
    if not api_key:
        if DEBUG: print("[DK_ATTR] MOUSER_API_KEY not set")
        return None

    url = f"{MOUSER_KEYWORD_URL}?apiKey={quote_plus(api_key)}"
    body = {"SearchByKeywordRequest": {"keyword": mpn_query, "records": 25, "startingRecord": 0}}
    r = _request("POST", url, headers=_mouser_headers(), json_body=body)
    if not r:
        return None
    try:
        j = r.json() or {}
    except Exception:
        return None

    # Strictly follow Mouser schema:
    # "SearchResults" -> { "NumberOfResult": <int>, "Parts": [ { .., "ProductAttributes": [..] } ] }
    parts = (((j.get("SearchResults") or {}).get("Parts")) or [])
    if not isinstance(parts, list) or not parts:
        return None

    target = _norm_mpn(mpn_query)
    def _mpn_of(p: Dict[str, Any]) -> str:
        return _norm_mpn(p.get("ManufacturerPartNumber") or "")

    exact = [p for p in parts if _mpn_of(p) == target]
    hit = exact[0] if exact else parts[0]

    if DEBUG:
        print("[DK_ATTR] MOUSER hit → MouserPartNumber:",
              hit.get("MouserPartNumber"), "MPN:", hit.get("ManufacturerPartNumber"))
    return hit

def fetch_attributes_for_mpn_mouser(mpn_query: str) -> Dict[str, Any]:
    """Fetch attributes from Mouser keyword search (self-contained, deep traversal)."""
    hit = _mouser_keyword_hit(mpn_query)
    if not hit:
        return {}

    # Extract attribute map and param rows from full ProductAttributes[]
    raw_attrs = hit.get("ProductAttributes") or []
    attrs_map = _mouser_attrs_to_map(raw_attrs)

    # Build param rows from ProductAttributes (id-less, but complete)
    param_rows: List[Dict[str, Any]] = []
    if isinstance(raw_attrs, list):
        for r in raw_attrs:
            if not isinstance(r, dict): 
                continue
            name = str(r.get("AttributeName") or "").strip()
            val  = str(r.get("AttributeValue") or "").strip()
            if not name or not val:
                continue
            param_rows.append({"id": f"attr:{name}", "name": name, "value": val})

    out: Dict[str, Any] = {}
    if attrs_map:
        out["attributes"] = attrs_map
    if param_rows:
        out["param_rows"] = param_rows  # feed ranker a full list

    url = (hit.get("ProductDetailUrl") or "").strip()
    if url:
        out["product_url"] = url
    mpn_mouser = (hit.get("MouserPartNumber") or "").strip()
    if mpn_mouser:
        out["mouser_part"] = mpn_mouser

    if DEBUG:
        print("[DK_ATTR] MOUSER product_url:", out.get("product_url"))
        print("[DK_ATTR] MOUSER attributes extracted:", len(attrs_map))
    return out

# ---------------- Digi-Key parameter rows → compact list (for ranker) ----------------
def _rows_to_param_list(parameters: Any) -> List[Dict[str, Any]]:
    """
    Convert Digi-Key 'Parameters' rows to a compact list for ranking:
    [{id: ParameterId, name: ParameterText, value?: ValueText}, ...]
    Only includes rows that have a usable id.
    """
    items: List[Dict[str, Any]] = []
    if not isinstance(parameters, (list, tuple)):
        return items

    def pick_name(d: Dict[str, Any]) -> str:
        for k in ("ParameterText", "Parameter", "Name", "DisplayName"):
            v = d.get(k)
            if isinstance(v, str) and v.strip():
                return v.strip()
        return "Attribute"

    def pick_value(d: Dict[str, Any]) -> str:
        for k in ("ValueText", "Value"):
            v = d.get(k)
            if isinstance(v, str) and v.strip():
                return v.strip()
        vals = d.get("Values")
        if isinstance(vals, list) and vals:
            return ", ".join([str(x).strip() for x in vals if str(x).strip()])
        return ""

    for row in parameters:
        if not isinstance(row, dict):
            continue
        pid = row.get("ParameterId") or row.get("Id") or row.get("ParameterID")
        if pid is None:
            continue
        sid = str(pid)
        nm = pick_name(row)
        val = pick_value(row)
        item = {"id": sid, "name": nm}
        if val:
            item["value"] = val
        items.append(item)
    return items

# ---------------- public API (Digi-Key first, fallback to Mouser) ----------------
def fetch_attributes_for_mpn(mpn: str) -> Dict[str, Any]:
    """
    Strategy:
      1) Try several query variants on Digi-Key KeywordSearch(mpn): as-is, '-'→'/', '/'→'-', no punctuation, spaces.
         Prefer parameters from the direct hit, else ProductDetails by ProductNumber.
      2) If Digi-Key yields no attributes, try the same variant set on Mouser keyword search
         and use SearchResults.Parts[].ProductAttributes (deep traversal).
      3) Return { product_url, dk_part?, mouser_part?, attributes, ranked_parameters? }.
    """
    mpn = (mpn or "").strip()
    if not mpn:
        return {}

    attrs_total: Dict[str, Any] = {}
    product_url: Optional[str] = None
    dk_product_number: Optional[str] = None
    digikey_param_rows: List[Dict[str, Any]] = []
    mouser_param_rows: List[Dict[str, Any]] = []
    mouser_part: Optional[str] = None

    # --- Try Digi-Key first over variant queries ---
    token = _get_digikey_token()
    if token:
        for q_mpn in _mpn_variants_for_search(mpn):
            hit = _keyword_exact_hit(token, q_mpn)
            if not hit:
                continue
            # Collect product URL and parameters directly if present
            product_url = (hit.get("ProductUrl") or hit.get("productUrl") or "").strip() or product_url
            dk_product_number = hit.get("ProductNumber") or hit.get("productNumber") or dk_product_number

            params = hit.get("Parameters") or hit.get("parameters") or []
            digikey_param_rows = _rows_to_param_list(params)
            if params:
                attrs_total.update(_to_attributes_map(params))
            # If nothing yet, dive into details by ProductNumber
            if not attrs_total and dk_product_number:
                details = _details_for_product_number(token, dk_product_number)
                if details:
                    product_obj = (
                        details.get("Product") or details.get("product") or
                        (details.get("ProductDetails") or {}).get("Product") or {}
                    )
                    params2 = (
                        product_obj.get("Parameters") or product_obj.get("parameters") or
                        details.get("Parameters") or details.get("parameters") or []
                    )
                    if params2:
                        attrs_total.update(_to_attributes_map(params2))
                        if not digikey_param_rows:
                            digikey_param_rows = _rows_to_param_list(params2)
            if attrs_total:
                break  # stop after first DK variant that yields attributes

    # --- Mouser fallback (also over variant queries) ---
    if not attrs_total:
        for q_mpn in _mpn_variants_for_search(mpn):
            mo = fetch_attributes_for_mpn_mouser(q_mpn)
            if not mo:
                continue
            attrs_total.update(mo.get("attributes") or {})
            if not product_url and mo.get("product_url"):
                product_url = mo["product_url"]
            if mo.get("mouser_part"):
                mouser_part = mo.get("mouser_part")
            if mo.get("param_rows"):
                mouser_param_rows = mo["param_rows"]
            if attrs_total:
                break  # first Mouser variant that yields attributes

    # ---------- Decide which rows to rank (DK rows first, else Mouser rows, else synthesize) ----------
    param_rows_for_ranker: List[Dict[str, Any]] = digikey_param_rows[:] or mouser_param_rows[:]
    if not param_rows_for_ranker and attrs_total:
        # synthesize rows from the attribute map so they can be ranked/sorted
        param_rows_for_ranker = [
            {"id": f"attr:{k}", "name": k, "value": str(v)}
            for k, v in attrs_total.items()
            if k and v is not None and str(v).strip()
        ]

    # --- Rank right after extraction (stateless)
    ranked_parameters: Optional[List[Dict[str, Any]]] = None
    try:
        if param_rows_for_ranker:
            if rank_parameter_ids:
                ranked_parameters = rank_parameter_ids(
                    param_rows_for_ranker, mpn=mpn, category=None, console_preview=True
                )
            else:
                # Deterministic fallback when LLM ranker is unavailable
                priority = (
                    "Voltage", "Current", "Power", "Frequency", "Speed", "Air Flow",
                    "Size", "Dimensions", "Width", "Height", "Depth", "Bearing",
                    "Connector", "Pin", "Package", "Mounting", "Material"
                )
                prio = {k.lower(): i for i, k in enumerate(priority)}
                ranked_parameters = sorted(
                    param_rows_for_ranker,
                    key=lambda r: prio.get(str(r.get("name","")).lower(), 999)
                )
    except Exception as e:
        if DEBUG: print("[DK_ATTR] ranker error:", e)

    out: Dict[str, Any] = {}
    if product_url:       out["product_url"] = product_url
    if dk_product_number: out["dk_part"] = dk_product_number
    if mouser_part:       out["mouser_part"] = mouser_part
    if attrs_total:       out["attributes"] = attrs_total
    if ranked_parameters: out["ranked_parameters"] = ranked_parameters

    if DEBUG:
        print("[DK_ATTR] final attributes keys:", len(attrs_total))
        if ranked_parameters:
            print("[DK_ATTR] ranked count:", len(ranked_parameters))
    return out

def enrich_payload_with_attributes(mpn: str, payload: Dict[str, Any]) -> Dict[str, Any]:
    """
    Merge fetched attributes/links into a replacement payload's 'base' block.
    """
    try:
        add = fetch_attributes_for_mpn(mpn)
        if not add:
            return payload
        base = payload.get("base") or {}
        if add.get("product_url") and not base.get("product_url"):
            base["product_url"] = add["product_url"]
        if add.get("dk_part") and not base.get("dk_part"):
            base["dk_part"] = add["dk_part"]
        if add.get("mouser_part") and not base.get("mouser_part"):
            base["mouser_part"] = add["mouser_part"]
        if add.get("attributes"):
            base_attrs = dict(base.get("attributes") or {})
            base_attrs.update(add["attributes"])
            base["attributes"] = base_attrs
        if add.get("ranked_parameters"):
            base["ranked_parameters"] = add["ranked_parameters"]
        payload["base"] = base
        return payload
    except Exception as e:
        if DEBUG: print("[DK_ATTR] enrich err", e)
        return payload
